3. 跨进程通信 方式 及 问题
==
    
<br/>
    
## 方式

- **1. Intent**
- **2. 共享文件**
- **3. Messenger**
- **5. AIDL**
- **6. ContentProvider**
- **7. Socket**
    
<br/>
    
## 问题

- **1. 静态成员 和 单例模式 完全失效**
- **2. 线程同步机制 完全失效**
- **3. SharedPreferences 可能性下降**：SharedPreferences 的读写有缓存机制，内存中会有 SharedPreferences 文件的缓存。在多进程的情况下，读写会不可靠。并且高并发的情况下，很大几率丢失数据。
- **4. Application 会创建多次**：一个组建跑在独立的进程中，系统要为其创建新的进程的同时，分配独立的虚拟机。**实质上，就是启动一个应用的过程，自然会创建 Application**（ **运行在不同进程中的组件是属于两个不同的虚拟机和 Application 的** ）。
    
<br/>
    
## 区别

| 方式 | 优点 | 缺点 | 适用场景 |
| :--- | :--- | :--- | :--- |
| Bundle | 简单易用 | 只能传输 Bundle 支持的数据类型 | 四大组件之间的进程通信 |
| 共享文件 | 简单易用 | 不适合高并发场景，并且无法做到进程间的即使通信 | 没有并发的环境，交换简单的数据实时性不高的场景 |
| ADIL | 功能强大，支持一对多的并发通信，也支持实时通信 | 使用稍微复杂，需要处理好线程同步 | 一对多的通信，并且有 RPC 需求 |
| Messenger | 功能一般，支持一对多串行通信，支持实时通信 | 不能很好处理高并发场景，也不支持 RPC ，数据通过 Message 进行传输。所以，只传输 Bundle 支持的数据类型 | 低并发的一对多即使通信，无 RPC 需求，或者无须要返回结果的 RPC 需求 |
| ContentProvider | 在数据源访问方面功能强大，支持一对多并发数据共享，可以通过 Call 方法扩展其他操作 | “受约束的 AIDL”，主要提供数据源的 “增删改查” 操作 | 一对多的进程间的数据共享 |
| Socket | 功能强大，可以通过网络传输字节流，支持一对多并发实时通信 | 实现细节繁琐，不能支持直接的 RPC | 网络数据交换 |
